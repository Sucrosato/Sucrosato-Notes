## 6.2 树的定义
根root、子树subtree
度degree：子树数
叶leaf：度为0
树的度：树内最大的度
孩子child
双亲parent
兄弟sibling
祖先
层次level
深度depth
有序树、无序树
森林forest：树的集合
## 6.3 树的抽象数据类型

## 6.4 树的存储结构
三种表示法：双亲表示法、孩子表示法、孩子兄弟表示法

双亲表示法：
   找双亲很方便
   
孩子表示法
   TreeDegree个指针域：
      度相差大时浪费空间

   按需分配：
   长子+孩子链表：
   双亲孩子表示法：
孩子兄弟表示法：
   长子+右兄弟
   *变形成二叉树？

## 6.5 二叉树的定义
度<=2
有序树（左子树、右子树）

特殊：
斜树（左斜树、右斜树）
满二叉树
   完全二叉树（满二叉树的子集，现有的结点与满二叉树编号相同，但是不满）

## 6.6 二叉树的性质
1. 第i层至多有$2^{i-1}$个结点
2. 深k的二叉树至多有$2^k-1$个结点
3. 终端结点数$n_0$与度为2的结点数$n_2$有关系：$$n_0=n_2+1$$
4. 对于有$n$个结点的完全二叉树：$$k=\lfloor\log_2{n}\rfloor+1$$
5. 对于有$n$个结点的*按层编号*的完全二叉树，
    1. 结点 $i(i>=2)$ 的双亲是结点$\lfloor i/2 \rfloor$
    2. 结点 $i$ 的左孩子是结点 $2i$（如果有，即 $2i<=n$ ）
    3. 结点 $i$ 的右孩子是结点 $2i+1$（如果有，即 $2i+1<=n$ ）

## 6.7 二叉树的存储结构
1. 顺序存储结构
    空结点为$\land$
    用于非完全二叉树浪费空间
2. 二叉链表（常用）
    lchild, data, rchild
## 6.8 遍历二叉树
1 前序遍历
    根-左-右
    ```
    void PreOrderTraverse(BiTree T)
    {
        if(T==NULL)
            return;
        printf("%c", T->data);
        PreOrderTraverse(T->lchild);
        PreOrderTraverse(T->rchild);
    }
    ```
2 中序遍历
    左-根-右
3 后序遍历
    左-右-根
4 层序遍历
    从上到下，从左到右
    
已知前、中序，求二叉树（已知前、后序不能确定二叉树）
## 6.9 二叉树的建立
二叉链表、前序遍历（也可以中序后序）、递归、空结点#

## 6.10 线索二叉树
$n+1$ 个空指针域
线索化：用空指针域的`lchild`表示前驱，`rchild`表示后驱，增加布尔型的`ltag`和`rtag`以表示指针域含义（中序遍历的双向链表）
线索化递归函数
经常需要遍历时的选择

## 6.11 树、森林和二叉树的转换
树之间的转换
    树转换为二叉树
    森林转换为二叉树
    二叉树转换为森林
    *转换成的二叉树，右结点代表兄弟，左结点代表孩子

树和森林的遍历
    树的遍历
        先根遍历
        后根遍历
    森林的遍历
        前序遍历
        后序遍历
        *都不会跨越树的顺序*
## 6.12 赫夫曼树及其应用
树的路径长度：
    树根到每一结点的分支数目之和
    带权路径长度WPL
赫夫曼树（最优二叉树）
    含有n个带权叶的树中，WPL最小的树
    构建方法：
        1. 将所有结点根据权值排序
        2. 取最小的两个结点组成新的二叉树，并重新以权值之和加入排序
        3. 重复步骤，直至只剩根节点T

赫夫曼编码：
    将字符作为叶结点，字符出现的频率作为权重，构建赫夫曼树并将左分支代表0，右分支代表1，得到的字符集编码



