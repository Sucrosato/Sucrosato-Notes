%%并非二分%%
（相对）内存越来越小！
增长速度：系统存储容量<<应用问题规模
访问速度：ms/ns
#### 高速缓存
分级组织：常用数据放在高层存储器
CPU-RAM-DISK-ARRAY

以page或block为单位
定制缓冲区
![[Pasted image 20250413155859.png]]

## B-树
平衡的多路 *multi-way* 搜索树
二叉树每d代合并，得到超级节点，$m=2^d$ 路，$m-1$ 个关键码

- 以超级节点为单位，针对外部查找，大大减少I/O次数
m阶B-树（m路平衡搜索树）
- 外部节点 *external nodes* 的深度统一相等
- 叶节点的深度统一相等

最多m-1个关键码、m个分支
最少分支数$\lceil m/2 \rceil-1$个关键码，分支数$n+1\geq\lceil m/2 \rceil$ ，对于树根大于等于2即可（修正案）
“$(\lceil m/2 \rceil,m)$树“

紧凑表示：省略引用、外部节点

#### `class BTNode`
内部用向量实现
`vector<T> key, child`

#### `class BTree`
\_size, \_order, \_root
上溢、下溢处理
查找、插入、删除

## 查找
只将必要的节点载入内存
遍历关键码，找到成功返回；失败继续深入下一个孩子（引用）
时间消耗：主要是载入内存操作，O(logn)
N个关键码->N+1个外部节点（失败可能）
$O(\log_m N)$
高度变化有限：$h=\Theta(\log_m N)$

## 插入
search
如果不存在，`key.insert(); child.insert() //叶节点孩子都为空，可直接插在末尾`
#### 发生上溢：分裂
取中位数到父亲，左右两边作为左右孩子
精妙：分裂后恰好高于下界
再发生上溢：再分裂
#### 分裂到根
中位数作为新的根，树增高一层
修正案（根可以只有两个分支）的原因
O(h)
## 删除
如果不是叶子，在右子树中找到最左后继，交换、删除
#### 发生下溢：旋转
如果$\lceil m/2 \rceil-2$节点的兄弟节点有至少$\lceil m/2 \rceil$个，则可将父节点纳入，兄弟节点的前驱/后继作为新的父节点
#### 发生下溢：合并
$\lceil m/2 \rceil-2$节点的兄弟节点只有$\lceil m/2 \rceil-1$个
用父节点黏合->
合并，必然合法
连续下溢：如法炮制
O(h)