局部性：连续访问的节点有大可能在上次访问的节点附近
## 逐层伸展
一旦被访问，节点->树根
最坏：分摊O(n)

## 双层伸展

向上追溯两层（4种）
#### zig-zag/zag-zig
与AVL树双旋完全等同
#### zig-zig/zag-zag %%龙的另一只眼睛%%
Tarjan: 先越级调整祖父，再调整父亲
（撇变成了捺）
e.g. 长撇，进行双层操作，一次缩短了（大致）一半高度
- 优点：最坏情况下，分摊复杂度O(logn)
奇数需要一次单层调整，不影响渐进复杂度

### 实现
继承自BST

重写search, insert, remove：
    search()会影响树的拓扑结构，变成了动态操作
#### `splay()`
while 有曾祖父
    zxg-zxg重构，attachAsLChild
    附到曾祖父上
如果还不是根，单层操作

#### `search()`
调用`searchIn()`
无论是否命中，`_root = splay()`
返回`_root`

#### `insert()`
`search()`失败后，根节点就是要接入的点%%唾手可得%%

#### `remove()`
`search()`成功后，直接删除`_root()`
找新根

## 讨论
#### 优点
不需要记录 高度、平衡因子
适合局部性强的情况
#### 局限
仍不能保证 *单次* 最坏情况的出现
不适用于 *效率敏感* 的场合
